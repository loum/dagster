{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dagster workflow management primer.","text":"<p>Dagster will prime a development environment that enables you to integrate directly into the Apache Airflow workflow management system with minimal fuss.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>Dagster can be used as a primer for your workflow management system.</p>"},{"location":"getting-started/#running-the-local-airflow-webserver-ui","title":"Running the Local Airflow Webserver UI","text":"<p>Launch the Airflow webserver UI in SequentialExector mode to visualise and interact with dashboard (<code>Ctrl-C</code> to stop): <pre><code>make local-airflow-start\n</code></pre> You can access your local Airflow webserver console via http://localhost:8888.</p>"},{"location":"getting-started/#creating-a-workflow-the-dag-file","title":"Creating a workflow: the DAG file","text":"<p>Airflow DAGs are written in Python and are technically just a Python module (with <code>.py</code> extension). DAGs are interpreted by Airflow via the DagBag facility and can then be scheduled to execute.</p> <p>DAGs files are placed under the <code>AIRFLOW__CORE__DAGS_FOLDER</code>. The directory location can be identified as follows: <pre><code>make print-AIRFLOW__CORE__DAGS_FOLDER\n</code></pre></p>"},{"location":"getting-started/#creating-a-dag-from-the-default-template","title":"Creating a DAG from the default template","text":"<p>The default DAG template can help you get started creating your new DAG. The template DAG at <code>src/dagster/dags/template.py</code> features a set of <code>start</code> and <code>end</code> \"book-end\" tasks that can be used to delimit your pipeline. You then add your own business related tasks in between.</p> <p>The <code>start</code> and <code>end</code> tasks are instantiated via Airflow's EmptyOperators and act as safe landing zones for your pipeline.</p> <p>Note</p> <p>More information around Airflow DAG creation and concepts is available at the Airflow tutorial.</p> <p>Copy <code>src/dagster/dags/template.py</code>  into a new Python file replacing <code>DAG_NAME</code> with something meaningful that best represents your new workflow: <pre><code>cp src/dagster/dags/template.py src/dagster/dags/&lt;DAG_NAME&gt;.py\n</code></pre> Provide a more detailed description about your new DAG by editing <code>src/dagster/dags/&lt;DAG_NAME&gt;.py</code> and replacing the <code>DESCRIPTION</code> variable value to suit. <code>DESCRIPTION</code> renders in the Airflow UI and helps visitors understand the intent behind your workflow.</p> <p>A quick validation of your new DAG can be performed with: <pre><code>make local-list-dags\n</code></pre></p>"},{"location":"getting-started/#default-dag-template-code-snippet","title":"Default DAG template code snippet","text":"<pre><code>\"\"\"The simplest DAG template.\n\n\"\"\"\nimport os\nimport airflow\n\nimport dagster.common.task\nfrom dagster.primer import Primer\n\n\nDAG_NAME = os.path.basename(os.path.splitext(__file__)[0]).replace(\"_\", \"-\")\nDESCRIPTION = \"Simple book-end DAG template to get you started\"\n\nPRIMER = Primer(dag_name=DAG_NAME, department=\"ADMIN\")\nPRIMER.dag_properties.update({\"description\": DESCRIPTION})\n\nDAG = airflow.DAG(\n    PRIMER.dag_id, default_args=PRIMER.default_args, **(PRIMER.dag_properties)\n)\n\nTASK_START = dagster.common.task.start(DAG, PRIMER.default_args)\n#\n# Add your content here.\n#\nTASK_END = dagster.common.task.end(DAG, PRIMER.default_args)\n\nTASK_START &gt;&gt; TASK_END  # pylint: disable=pointless-statement\n</code></pre>"},{"location":"getting-started/#things-to-consider-when-creating-your-dags","title":"Things to consider when creating your DAGs","text":"<p>Airflow as a workflow management tool can be utilised as shared infrastructure between different teams and entities within the organisation. Having more contributors to the platform introduces a communal aspect where everyone can create and leverage existing code and tooling. However, as the number of DAGs begins to increase the platform could also increase in complexity. The following guidelines should be considered when creating your DAGs.</p>"},{"location":"getting-started/#naming-standards","title":"Naming standards","text":"<p>The DAG name (<code>DAG_NAME</code>) plays an integral part in the operation of Airflow. It is also the token that presents in the Airflow web UI.</p> <p>The DAG names are made up of three components separated by underscores (<code>_</code>):</p> <ol> <li>Department or team name (<code>department</code> parameter to <code>dagster.Primer</code>)</li> <li>Short name to give DAG some operational context (<code>dag_name</code> parameter to <code>dagster.Primer</code>)</li> <li>Environment is added automatically based on the setting of the environment variable <code>AIRFLOW_CUSTOM_ENV</code> (defaults to <code>local</code>)</li> </ol> <p>For example, the DAG name generated from the <code>src/dagster/dags/template.py</code> becomes <code>ADMIN-TEMPLATE_LOCAL</code></p> <p>Note</p> <p>Ensure the <code>dag_name</code> and <code>department</code> combination is unique amongst all DAGS under <code>AIRFLOW__CORE__DAGS_FOLDER</code> as this could cause an implicit conflict that is difficult to troubleshoot.</p>"},{"location":"reference/dagster/connection/","title":"connection.py","text":"<p>Airflow connection helpers.</p>"},{"location":"reference/dagster/connection/#dagster.connection.delete_connection","title":"<code>delete_connection(key)</code>","text":"<p>Delete connection <code>key</code> from DB.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the Airflow Variable key.</p> required Source code in <code>dagster/connection.py</code> <pre><code>def delete_connection(key: str) -&gt; None:\n    \"\"\"Delete connection `key` from DB.\n\n    Parameters:\n        key: The name of the Airflow Variable key.\n\n    \"\"\"\n    log.info('Attempting to delete Airflow connection with conn_id: \"%s\"', key)\n    with LAZY_AF_UTILS.session.create_session() as session:  # type: ignore[operator,attr-defined]\n        try:\n            to_delete = (\n                session.query(LAZY_AF_MODELS.Connection)\n                .filter(LAZY_AF_MODELS.Connection.conn_id == key)  # type: ignore[attr-defined]\n                .one()\n            )\n        except exc.NoResultFound:\n            log.warning('Did not find a connection with conn_id: \"%s\"', key)\n        except exc.MultipleResultsFound:\n            log.warning('Found more than one connection with conn_id: \"%s\"', key)\n        else:\n            session.delete(to_delete)\n            log.info('Successfully deleted Airflow connection with conn_id: \"%s\"', key)\n</code></pre>"},{"location":"reference/dagster/connection/#dagster.connection.list_connections","title":"<code>list_connections()</code>","text":"<p>Return connection information from Airflow connections table.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of all available connections.</p> Source code in <code>dagster/connection.py</code> <pre><code>def list_connections() -&gt; list[str]:\n    \"\"\"Return connection information from Airflow connections table.\n\n    Returns:\n        list of all available connections.\n\n    \"\"\"\n    with LAZY_AF_UTILS.session.create_session() as session:  # type: ignore[operator,attr-defined]\n        query = session.query(LAZY_AF_MODELS.Connection)\n        conns = query.all()\n\n        LAZY_AF_CLI_SIMPLE_TABLE.AirflowConsole().print_as(  # type: ignore[operator]\n            data=conns,\n            output=\"table\",\n            mapper=LAZY_AF_CONNECTION_COMMAND._connection_mapper,  # pylint: disable=protected-access\n        )\n\n    return [x.conn_id for x in conns]\n</code></pre>"},{"location":"reference/dagster/connection/#dagster.connection.set_connection","title":"<code>set_connection(path_to_connections)</code>","text":"<p>Add configuration items to Airflow <code>airflow.models.Connection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_connections</code> <code>str</code> <p>File path the the Airflow connections configuration.</p> required Source code in <code>dagster/connection.py</code> <pre><code>def set_connection(path_to_connections: str) -&gt; None:\n    \"\"\"Add configuration items to Airflow `airflow.models.Connection`.\n\n    Parameters:\n        path_to_connections: File path the the Airflow connections configuration.\n\n    \"\"\"\n    raw_connections = filester.get_directory_files(\n        path_to_connections, file_filter=\"*.json\"\n    )\n    log.info('Checking \"%s\" for Airflow connections ...', path_to_connections)\n    for raw_connection in raw_connections:\n        log.info('Found Airflow connection \"%s\"', raw_connection)\n        with open(\n            raw_connection,\n            encoding=\"utf-8\",\n        ) as json_file:\n            data = json.load(json_file)\n\n            conn_extra = data.pop(\"conn_extra\", None)\n            new_conn = LAZY_AF_MODELS.Connection(**data)  # type: ignore[operator]\n            if conn_extra:\n                new_conn.set_extra(json.dumps(conn_extra))\n\n            with LAZY_AF_UTILS.session.create_session() as session:  # type: ignore\n                state = \"OK\"\n                if (\n                    session.query(LAZY_AF_MODELS.Connection)\n                    .filter(\n                        LAZY_AF_MODELS.Connection.conn_id == new_conn.conn_id  # type: ignore\n                    )\n                    .first()\n                ):\n                    state = \"already exists\"\n                else:\n                    session.add(new_conn)\n\n                msg = f'Airflow connection \"{data.get(\"conn_id\")}\" create status'\n                log.info(\"%s: %s\", msg, state)\n</code></pre>"},{"location":"reference/dagster/connection/#dagster.connection.set_logging_connection","title":"<code>set_logging_connection(path_to_connections=None)</code>","text":"<p>Logging configuration to Airflow <code>airflow.models.Connection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_connections</code> <code>Optional[str]</code> <p>Optional file path the the Airflow connections configuration.</p> <code>None</code> Source code in <code>dagster/connection.py</code> <pre><code>def set_logging_connection(path_to_connections: Optional[str] = None) -&gt; None:\n    \"\"\"Logging configuration to Airflow `airflow.models.Connection`.\n\n    Parameters:\n        path_to_connections: Optional file path the the Airflow connections configuration.\n\n    \"\"\"\n    if REMOTE_LOGGING:\n        if not path_to_connections:\n            path_to_connections = os.path.join(\n                pathlib.Path(__file__).resolve().parents[0],\n                \"config\",\n                \"templates\",\n                \"connections\",\n                \"logging\",\n                \"sas\",\n            )\n        set_templated_connection(path_to_connections)\n    else:\n        log.info('Remote logging not enabled. Check \"AIRFLOW__LOGGING__REMOTE_LOGGING\"')\n</code></pre>"},{"location":"reference/dagster/connection/#dagster.connection.set_templated_connection","title":"<code>set_templated_connection(path_to_connections, environment_override=None)</code>","text":"<p>Add configuration items to Airflow <code>airflow.models.Connection</code>.</p> <p>Connection templates are sourced from the <code>path_to_connections</code> directory and should feature a <code>*.j2</code> extension. Each template file should feature a single <code>airflow.models.Connection</code> definition in JSON format. For example: <pre><code>    {\n        \"conn_id\": \"azure_wasb_logs\",\n        \"conn_type\": \"wasb\",\n        \"login\": \"login\",\n        \"password\": \"secret\"\n    }\n</code></pre></p> <p>Connections that are defined in the environment path override, <code>environment_override</code>, will task precedence over the defaults settings.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_connections</code> <code>str</code> <p>File path the the Airflow connections configuration.</p> required <code>environment_override</code> <code>Optional[str]</code> <p>Provide an environment value that overrides settings defined under <code>path_to_connections</code>.</p> <code>None</code> Source code in <code>dagster/connection.py</code> <pre><code>def set_templated_connection(\n    path_to_connections: str, environment_override: Optional[str] = None\n) -&gt; None:\n    \"\"\"Add configuration items to Airflow `airflow.models.Connection`.\n\n    Connection templates are sourced from the `path_to_connections` directory and should feature\n    a `*.j2` extension. Each template file should feature a single\n    `airflow.models.Connection` definition in JSON format. For example:\n    ```\n        {\n            \"conn_id\": \"azure_wasb_logs\",\n            \"conn_type\": \"wasb\",\n            \"login\": \"login\",\n            \"password\": \"secret\"\n        }\n    ```\n\n    Connections that are defined in the environment path override, `environment_override`, will\n    task precedence over the defaults settings.\n\n    Parameters:\n        path_to_connections: File path the the Airflow connections configuration.\n        environment_override: Provide an environment value that overrides settings defined\n            under `path_to_connections`.\n\n    \"\"\"\n    config_paths = []\n    if environment_override is not None:\n        config_paths.append(\n            os.path.join(path_to_connections, environment_override.lower())\n        )\n    config_paths.append(path_to_connections)\n\n    for config_path in config_paths:\n        for path_to_variable_template in filester.get_directory_files(\n            config_path, file_filter=\"*.j2\"\n        ):\n            rendered_content: Optional[str] = build_from_template(\n                {}, path_to_variable_template, write_output=False\n            )\n            if rendered_content is None:\n                continue\n\n            data = json.loads(rendered_content)\n\n            conn_extra = data.pop(\"conn_extra\", None)\n            new_conn = LAZY_AF_MODELS.Connection(**data)  # type: ignore[operator]\n            if conn_extra:\n                new_conn.set_extra(json.dumps(conn_extra))\n\n            with LAZY_AF_UTILS.session.create_session() as session:  # type: ignore[attr-defined]\n                state = \"OK\"\n                if (\n                    session.query(LAZY_AF_MODELS.Connection)\n                    .filter(\n                        LAZY_AF_MODELS.Connection.conn_id == new_conn.conn_id  # type: ignore\n                    )\n                    .first()\n                ):\n                    state = \"already exists\"\n                else:\n                    session.add(new_conn)\n\n                msg = f'Airflow connection \"{data.get(\"conn_id\")}\" create status'\n                log.info(\"%s: %s\", msg, state)\n</code></pre>"},{"location":"reference/dagster/primer/","title":"primer.py","text":"<p>Primer provides consistent context for your program's workflows.</p> <ul> <li><code>dag_name</code> and <code>department</code> form the <code>dag_id</code> that presents in the Airflow dashboard.</li> <li><code>department</code> organisation/department/team delimiter to categorise DAG ID.</li> <li><code>airflow_env_variable</code> is the name used in the Airflow infrustructure   environment that determines the instance context. For example,   <code>local</code>, <code>development</code> and <code>production</code>. Environment naming rules are not enforced.</li> </ul> <p><code>kwargs</code> accepts parameters that are passed into <code>airflow.models.dag.DAG</code>.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer","title":"<code>Primer</code>","text":"<p>Common components that can get your DAGs running with minimal fuss.</p> Source code in <code>dagster/primer.py</code> <pre><code>class Primer:\n    \"\"\"Common components that can get your DAGs running with minimal fuss.\"\"\"\n\n    def __init__(\n        self,\n        dag_name: str,\n        department: str = \"dept\",\n        airflow_env_variable: str = \"AIRFLOW_CUSTOM_ENV\",\n    ):\n        self.__dag_name = dag_name\n        self.__department = department\n        self.__airflow_env_variable = airflow_env_variable\n        self.__default_args = {\n            \"owner\": \"airflow\",\n            \"depends_on_past\": False,\n            \"email_on_failure\": False,\n            \"email_on_retry\": False,\n            \"retries\": 2,\n            \"retry_delay\": datetime.timedelta(minutes=5),\n        }\n        self.__dag_properties = {\n            \"schedule_interval\": None,\n            \"start_date\": Primer.derive_start_date(),\n            \"catchup\": False,\n        }\n\n    @property\n    def dag_name(self) -&gt; str:\n        \"\"\"`dag_name` getter.\"\"\"\n        return self.__dag_name\n\n    @property\n    def department(self) -&gt; str:\n        \"\"\"`department` getter.\"\"\"\n        return self.__department\n\n    @property\n    def airflow_env_variable(self) -&gt; str:\n        \"\"\"`airflow_env_variable` getter.\"\"\"\n        return self.__airflow_env_variable\n\n    @property\n    def dag_id(self) -&gt; str:\n        \"\"\"`dag_id` getter.\"\"\"\n        return f\"{self.department}_{self.dag_name}_{self.get_env}\".upper()\n\n    @property\n    def default_args(self) -&gt; dict[str, Any]:\n        \"\"\"The DAG's Operator-specific default arguments.\"\"\"\n        return self.__default_args\n\n    @property\n    def dag_properties(self) -&gt; dict[Any, Any]:\n        \"\"\"Provide sane DAG parameter defaults.\"\"\"\n        return self.__dag_properties\n\n    @property\n    def get_env(self) -&gt; str:\n        \"\"\"Return current environement name.\"\"\"\n        return os.environ.get(self.airflow_env_variable, \"local\").upper()\n\n    @staticmethod\n    def derive_start_date(timezone: str = \"Australia/Melbourne\") -&gt; datetime.datetime:\n        \"\"\"Define the DAG start date.\n\n        Supported date formats are `%Y-%m-%d`.\n\n        If no date is identified in the `CONFIG` then date defaults\n        to the first day of the current year.\n\n        Parameters:\n            timezone: Timezone context.\n\n        Returns:\n            `datetime` object representing the DAG start date.\n\n        \"\"\"\n\n        def current_year() -&gt; int:\n            return datetime.datetime.now().year\n\n        local_tz = pendulum.timezone(timezone)  # type: ignore\n\n        _dt = datetime.datetime(current_year(), 1, 1, tzinfo=local_tz)\n\n        return _dt\n</code></pre>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.airflow_env_variable","title":"<code>airflow_env_variable: str</code>  <code>property</code>","text":"<p><code>airflow_env_variable</code> getter.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.dag_id","title":"<code>dag_id: str</code>  <code>property</code>","text":"<p><code>dag_id</code> getter.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.dag_name","title":"<code>dag_name: str</code>  <code>property</code>","text":"<p><code>dag_name</code> getter.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.dag_properties","title":"<code>dag_properties: dict[Any, Any]</code>  <code>property</code>","text":"<p>Provide sane DAG parameter defaults.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.default_args","title":"<code>default_args: dict[str, Any]</code>  <code>property</code>","text":"<p>The DAG's Operator-specific default arguments.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.department","title":"<code>department: str</code>  <code>property</code>","text":"<p><code>department</code> getter.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.get_env","title":"<code>get_env: str</code>  <code>property</code>","text":"<p>Return current environement name.</p>"},{"location":"reference/dagster/primer/#dagster.primer.Primer.derive_start_date","title":"<code>derive_start_date(timezone='Australia/Melbourne')</code>  <code>staticmethod</code>","text":"<p>Define the DAG start date.</p> <p>Supported date formats are <code>%Y-%m-%d</code>.</p> <p>If no date is identified in the <code>CONFIG</code> then date defaults to the first day of the current year.</p> <p>Parameters:</p> Name Type Description Default <code>timezone</code> <code>str</code> <p>Timezone context.</p> <code>'Australia/Melbourne'</code> <p>Returns:</p> Type Description <code>datetime</code> <p><code>datetime</code> object representing the DAG start date.</p> Source code in <code>dagster/primer.py</code> <pre><code>@staticmethod\ndef derive_start_date(timezone: str = \"Australia/Melbourne\") -&gt; datetime.datetime:\n    \"\"\"Define the DAG start date.\n\n    Supported date formats are `%Y-%m-%d`.\n\n    If no date is identified in the `CONFIG` then date defaults\n    to the first day of the current year.\n\n    Parameters:\n        timezone: Timezone context.\n\n    Returns:\n        `datetime` object representing the DAG start date.\n\n    \"\"\"\n\n    def current_year() -&gt; int:\n        return datetime.datetime.now().year\n\n    local_tz = pendulum.timezone(timezone)  # type: ignore\n\n    _dt = datetime.datetime(current_year(), 1, 1, tzinfo=local_tz)\n\n    return _dt\n</code></pre>"},{"location":"reference/dagster/templater/","title":"templater.py","text":"<p>Templating capability.</p>"},{"location":"reference/dagster/templater/#dagster.templater.build_from_template","title":"<code>build_from_template(env_map, template_file_path, write_output=False)</code>","text":"<p>Take <code>template_file_path</code> and template against variables defined by <code>env_map</code>.</p> <p><code>template_file_path</code> needs to end with a <code>.j2</code> extension as the generated content will be output to the <code>template_file_path</code> less the <code>.j2</code>.</p> <p>A special custom filter <code>env_override</code> is available to bypass <code>env_map</code> and source the environment for variable substitution. Use the custom filter <code>env_override</code> in your template as follows: <pre><code>\"test\" : {{ \"default\" | env_override('CUSTOM') }}\n</code></pre></p> <p>Provided an environment variable as been set: <pre><code>export CUSTOM=some_value\n</code></pre></p> <p>The template will render: <pre><code>some_value\n</code></pre></p> <p>Otherwise: <pre><code>default\n</code></pre></p> Source code in <code>dagster/templater.py</code> <pre><code>def build_from_template(\n    env_map: dict, template_file_path: str, write_output: bool = False\n) -&gt; str:\n    \"\"\"Take `template_file_path` and template against variables defined by `env_map`.\n\n    `template_file_path` needs to end with a `.j2` extension as the generated\n    content will be output to the `template_file_path` less the `.j2`.\n\n    A special custom filter `env_override` is available to bypass `env_map` and\n    source the environment for variable substitution. Use the custom filter\n    `env_override` in your template as follows:\n    ```\n    \"test\" : {{ \"default\" | env_override('CUSTOM') }}\n    ```\n\n    Provided an environment variable as been set:\n    ```\n    export CUSTOM=some_value\n    ```\n\n    The template will render:\n    ```\n    some_value\n    ```\n\n    Otherwise:\n    ```\n    default\n    ```\n\n    \"\"\"\n\n    def env_override(value: str, key: str) -&gt; str:\n        return os.getenv(key, value)\n\n    target_template_file_path = os.path.splitext(template_file_path)\n\n    output = \"\"\n    try:\n        file_loader = jinja2.FileSystemLoader(os.path.dirname(template_file_path))\n        j2_env = jinja2.Environment(autoescape=True, loader=file_loader)\n\n        j2_env.filters[\"env_override\"] = env_override\n        template = j2_env.get_template(os.path.basename(template_file_path))\n\n        output = template.render(**env_map)\n\n        if write_output:\n            with tempfile.NamedTemporaryFile() as out_fh:\n                out_fh.write(output.encode())\n                out_fh.flush()\n                shutil.copy(out_fh.name, target_template_file_path[0])\n                logging.info(\n                    'Templated file \"%s\" generated', target_template_file_path[0]\n                )\n    except jinja2.exceptions.TemplateNotFound as err:\n        logging.error('Skipping templating: TemplateNotFound \"%s\"', err)\n\n    return output\n</code></pre>"},{"location":"reference/dagster/variable/","title":"variable.py","text":"<p>Dagster Airflow variable helpers.</p>"},{"location":"reference/dagster/variable/#dagster.variable.del_variable_key","title":"<code>del_variable_key(key)</code>","text":"<p>Airflow Variable delete helper.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The name of the Airflow Variable key.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the Airflow Variable key was successfully deleted. Otherwise <code>False</code>.</p> Source code in <code>dagster/variable.py</code> <pre><code>def del_variable_key(key: str) -&gt; bool:\n    \"\"\"Airflow Variable delete helper.\n\n    Parameters:\n        key: The name of the Airflow Variable key.\n\n    Returns:\n        `True` if the Airflow Variable key was successfully deleted. Otherwise `False`.\n\n    \"\"\"\n    status = False\n    log.info('Deleting variable \"%s\"', key)\n    status = LAZY_AF_MODELS.Variable.delete(key)  # type: ignore[attr-defined]\n    if not status:\n        log.warning('Variable \"%s\" delete failed', key)\n\n    return status == 1 or False\n</code></pre>"},{"location":"reference/dagster/variable/#dagster.variable.del_variables","title":"<code>del_variables(path_to_variables)</code>","text":"<p>Delete variable items from Airflow <code>airflow.models.Variable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_variables</code> <code>str</code> <p>File path the the Airflow variable configuration.</p> required Source code in <code>dagster/variable.py</code> <pre><code>def del_variables(path_to_variables: str) -&gt; None:\n    \"\"\"Delete variable items from Airflow `airflow.models.Variable`.\n\n    Parameters:\n        path_to_variables: File path the the Airflow variable configuration.\n\n    \"\"\"\n    env_map: dict = ENV_FILE.get(RUN_CONTEXT, {})\n\n    for path_to_variable_template in filester.get_directory_files(\n        path_to_variables, file_filter=\"*.j2\"\n    ):\n        rendered_content: Optional[str] = build_from_template(\n            env_map, path_to_variable_template, write_output=False\n        )\n        if rendered_content is None:\n            continue\n\n        data = json.loads(rendered_content)\n\n        for var_name in data.keys():\n            del_variable_key(var_name)\n</code></pre>"},{"location":"reference/dagster/variable/#dagster.variable.get_variable","title":"<code>get_variable(name)</code>","text":"<p>Display variable by a given <code>name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Airflow Variable identifier.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>the JSON value as a Python <code>dict</code> else None.</p> Source code in <code>dagster/variable.py</code> <pre><code>def get_variable(name: str) -&gt; dict[str, Any]:\n    \"\"\"Display variable by a given `name`.\n\n    Parameters:\n        name: Airflow Variable identifier.\n\n    Returns:\n        the JSON value as a Python `dict` else None.\n\n    \"\"\"\n    return LAZY_AF_MODELS.Variable.get(  # type: ignore[attr-defined]\n        name, default_var=None, deserialize_json=True\n    )\n</code></pre>"},{"location":"reference/dagster/variable/#dagster.variable.list_variables","title":"<code>list_variables()</code>","text":"<p>list the variable items from Airflow <code>airflow.models.Variable</code>.</p> <p>Returns:</p> Type Description <code>Iterator[tuple[str, int]]</code> <p>A generator-type object with each Airflow Variable returned by the query.</p> Source code in <code>dagster/variable.py</code> <pre><code>def list_variables() -&gt; Iterator[tuple[str, int]]:\n    \"\"\"list the variable items from Airflow `airflow.models.Variable`.\n\n    Returns:\n        A generator-type object with each Airflow Variable returned by the query.\n\n    \"\"\"\n    with LAZY_AF_UTILS.session.create_session() as session:  # type: ignore[attr-defined]\n        qry = session.query(LAZY_AF_MODELS.Variable).all()\n\n        data = json.JSONDecoder()\n        for var in qry:\n            try:\n                val = data.decode(var.val)\n            except Exception:  # pylint: disable=broad-except\n                val = var.val\n            yield val\n</code></pre>"},{"location":"reference/dagster/variable/#dagster.variable.set_variables","title":"<code>set_variables(path_to_variables, environment_override=None)</code>","text":"<p>Add variable items to Airflow <code>airflow.models.Variable</code>.</p> <p>Variables that are defined in the environment path override, <code>environment_override</code>, will task precedence over the defaults settings.</p> <p>Parameters:</p> Name Type Description Default <code>path_to_variables</code> <code>str</code> <p>File path the the Airflow variable configuration.</p> required <code>environment_override</code> <code>Optional[str]</code> <p>Provide an environment value that overrides settings defined under <code>path_to_connections</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of variables inserted.</p> Source code in <code>dagster/variable.py</code> <pre><code>def set_variables(\n    path_to_variables: str, environment_override: Optional[str] = None\n) -&gt; int:\n    \"\"\"Add variable items to Airflow `airflow.models.Variable`.\n\n    Variables that are defined in the environment path override, `environment_override`, will\n    task precedence over the defaults settings.\n\n    Parameters:\n        path_to_variables: File path the the Airflow variable configuration.\n        environment_override: Provide an environment value that overrides settings defined\n            under `path_to_connections`.\n\n    Returns:\n        The number of variables inserted.\n\n    \"\"\"\n    env_map: dict = ENV_FILE.get(RUN_CONTEXT, {})\n\n    counter = 0\n    config_paths = []\n    if environment_override is not None:\n        config_paths.append(\n            os.path.join(path_to_variables, environment_override.lower())\n        )\n    config_paths.append(path_to_variables)\n\n    for config_path in config_paths:\n        for path_to_variable_template in filester.get_directory_files(\n            config_path, file_filter=\"*.j2\"\n        ):\n            rendered_content: Optional[str] = build_from_template(\n                env_map, path_to_variable_template, write_output=False\n            )\n            if rendered_content is None:\n                continue\n\n            data = json.loads(rendered_content)\n\n            for var_name, values in data.items():\n                if get_variable(var_name):\n                    log.info(\n                        'Inserting variable \"%s\" skipped: already exists', var_name\n                    )\n                else:\n                    log.info('Inserting variable \"%s\"', var_name)\n                    LAZY_AF_MODELS.Variable.set(  # type: ignore[attr-defined]\n                        var_name, json.dumps(values, indent=4)\n                    )\n                    counter += 1\n\n    return counter\n</code></pre>"},{"location":"reference/dagster/dags/bootstrap/","title":"bootstrap.py","text":"<p>Bootstrap takes care of Airflow instance startup dependencies.</p>"},{"location":"reference/dagster/dags/bootstrap/#dagster.dags.bootstrap.config_path","title":"<code>config_path()</code>","text":"<p>Bootstrapper configuration path.</p> <p>Returns:</p> Type Description <code>str</code> <p>Python string representing the fully qualified path to the custom configuration.</p> Source code in <code>dagster/dags/bootstrap.py</code> <pre><code>def config_path() -&gt; str:\n    \"\"\"Bootstrapper configuration path.\n\n    Returns:\n        Python string representing the fully qualified path to the custom configuration.\n\n    \"\"\"\n    def inner():\n        return os.path.join(pathlib.Path(__file__).resolve().parents[1], \"config\")\n\n    return inner()\n</code></pre>"},{"location":"reference/dagster/dags/bootstrap/#dagster.dags.bootstrap.dag_name","title":"<code>dag_name()</code>","text":"<p>Use the DAG module name as the default DAG name.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representation of the Airflow DAG name.</p> Source code in <code>dagster/dags/bootstrap.py</code> <pre><code>def dag_name() -&gt; str:\n    \"\"\"Use the DAG module name as the default DAG name.\n\n    Returns:\n        String representation of the Airflow DAG name.\n\n    \"\"\"\n\n    def inner():\n        return os.path.basename(os.path.splitext(__file__)[0]).replace(\"_\", \"-\")\n\n    return inner()\n</code></pre>"},{"location":"reference/dagster/dags/bootstrap/#dagster.dags.bootstrap.dag_params","title":"<code>dag_params()</code>","text":"<p>Bootstrapper DAG level parameter initialisation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Python dictionary of bootrapper parameters at the DAG level.</p> Source code in <code>dagster/dags/bootstrap.py</code> <pre><code>def dag_params() -&gt; dict:\n    \"\"\"Bootstrapper DAG level parameter initialisation.\n\n    Returns:\n        Python dictionary of bootrapper parameters at the DAG level.\n\n    \"\"\"\n\n    def inner():\n        return {\n            \"tags\": [dag_name().upper()],\n            \"schedule_interval\": \"@once\",\n            \"is_paused_upon_creation\": False,\n        }\n\n    return inner()\n</code></pre>"},{"location":"reference/dagster/dags/bootstrap/#dagster.dags.bootstrap.load_auth","title":"<code>load_auth()</code>","text":"<p>Task wrapper around setting the Airflow Admin/Superuser account.</p> Source code in <code>dagster/dags/bootstrap.py</code> <pre><code>@task(task_id=\"set-authentication\")\ndef load_auth() -&gt; None:\n    \"\"\"Task wrapper around setting the Airflow Admin/Superuser account.\"\"\"\n    return dagster.user.set_authentication()\n</code></pre>"},{"location":"reference/dagster/dags/bootstrap/#dagster.dags.bootstrap.load_connections","title":"<code>load_connections(path_to_connections, environment_override=None)</code>","text":"<p>Task wrapper to add configuration items to Airflow <code>airflow.models.Connection</code>.</p> Source code in <code>dagster/dags/bootstrap.py</code> <pre><code>@task(task_id=\"load-connections\")\ndef load_connections(\n    path_to_connections: str, environment_override: Optional[str] = None\n) -&gt; None:\n    \"\"\"Task wrapper to add configuration items to Airflow `airflow.models.Connection`.\"\"\"\n    return dagster.connection.set_templated_connection(\n        path_to_connections=path_to_connections,\n        environment_override=environment_override,\n    )\n</code></pre>"},{"location":"reference/dagster/dags/bootstrap/#dagster.dags.bootstrap.task_load_dag_variables","title":"<code>task_load_dag_variables(path_to_variables, environment_override=None)</code>","text":"<p>Task wrapper to add DAG variable items to Airflow <code>airflow.models.Variable</code>.</p> Source code in <code>dagster/dags/bootstrap.py</code> <pre><code>@task(task_id=\"load-dag-variables\")\ndef task_load_dag_variables(\n    path_to_variables: str, environment_override: Optional[str] = None\n) -&gt; int:\n    \"\"\"Task wrapper to add DAG variable items to Airflow `airflow.models.Variable`.\"\"\"\n    return dagster.variable.set_variables(\n        path_to_variables=path_to_variables,\n        environment_override=environment_override,\n    )\n</code></pre>"},{"location":"reference/dagster/dags/bootstrap/#dagster.dags.bootstrap.task_load_task_variables","title":"<code>task_load_task_variables(path_to_variables, environment_override=None)</code>","text":"<p>Task wrapper to add task variable items to Airflow <code>airflow.models.Variable</code>.</p> Source code in <code>dagster/dags/bootstrap.py</code> <pre><code>@task(task_id=\"load-task-variables\")\ndef task_load_task_variables(\n    path_to_variables: str, environment_override: Optional[str] = None\n) -&gt; int:\n    \"\"\"Task wrapper to add task variable items to Airflow `airflow.models.Variable`.\"\"\"\n    return dagster.variable.set_variables(\n        path_to_variables=path_to_variables,\n        environment_override=environment_override,\n    )\n</code></pre>"}]}